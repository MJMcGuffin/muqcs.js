
<html>
<body>
Open a console (in Chrome, this is done by selecting 'Developer Tools'). From the console prompt, you can call functions in the code and see output printed to the console.

<p>
Or go to the <a href="https://github.com/MJMcGuffin/muqcs">github repository</a> page.
</p>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/13.0.2/math.js"></script>

<script>

// CONVENTIONs
//
// Assume that, in a quantum circuit with n qubits, the qubits are numbered
// from top to bottom as 0 to (n-1), respectively, and furthermore that the
// top qubit is the least significant bit (LSB), and the bottom is the most
// significant bit (MSB).  For example, if there are 3 qubits labeled q0, q1, q2,
// from top to bottom, these might store (q2,q1,q0) = (0,1,1) to encode 3
// or (q2,q1,q0) = (1,0,0) to encode 4.  Given these assumptions, there are
// two ways to simulate the circuit, described below, that correspond to
// different matrices and different orderings for tensor products.
// Sometimes the terms "big-endian" or "little-endian" are used to refer
// to choices related to this, but I haven't found clear definitions
// or consistent usage of these terms.
//
// Common software convention:
// - Tensor products are done in order of decreasing bit significance.
//   https://quantumcomputing.stackexchange.com/questions/8244/big-endian-vs-little-endian-in-qiskit
//   seems to confirm that Qiskit works this way.
// - In a 2-qubit circuit, if we have a 2-qubit gate where q0 is a control
//   bit and q1 has a conditionally applied operation with 2x2 matrix [a b; c d],
//   the 4x4 matrix for the gate would be [1 0 0 0; 0 a 0 b; 0 0 1 0; 0 c 0 d],
//   which is endian-reversed with how 4x4 matrices are usually presented in
//   textbooks on quantum computing.
//   See https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Basis-vector-ordering-in-Qiskit
// - In a 3-qubit circuit, the state vector would contain 8 elements,
//   and the 2nd of these would correspond to (q2,q1,q0) = (0,0,1),
//   which is more natural for reading.  This appears to match the
//   presentation of output from Quirk and IBM Quantum Composer.
//   Quirk's doc/README.md file ( https://github.com/Strilanc/Quirk/blob/master/doc/README.md )
//   states "Kets are big-endian. |00101> is 5, not 20",
//   and https://algassert.com/post/1707 further discusses this.
//
// Textbook convention:
// - Tensor products are done in order of increasing bit significance.
//   This seems to match when
//   https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Basis-vector-ordering-in-Qiskit
//   states "Within the physics community, the qubits of a multi-qubit systems
//   are typically ordered with the first qubit on the left-most side of the
//   tensor product and the last qubit on the right-most side."
// - The same 4x4 matrix mentioned earlier, with q0 acting as a control bit,
//   would now be [1 0 0 0; 0 1 0 0; 0 0 a b; 0 0 c d] which is how they
//   are usually presented in textbooks on quantum computing.
// - In a 3-qubit circuit, the state vector would contain 8 elements, and
//   the 2nd of these would correspond to (q0,q1,q2) = (0,0,1).
//   Such a vector would have to be endian-reversed for more natural reading.
//
// We could just implement one of the above conventions in the code,
// but I found it instructive to try to implement both and have a global flag
// to switch between the two.
//
let usingTextbookConvention = false;


let defaultDecimalPrecision = 3;
let precisionForApproximateComparison = 0.01;


class Util {
    static assert( condition, message ) {
        if ( ! condition ) {
            console.log( "ASSERTION ERROR: " + message );
            console.trace(); // causes line numbers to be printed
        }
    }
    // Let n be a power of 2. This returns the reverse of i in binary, with respect to n.
    // For example, if n===16, the reverse of 1 is 8, the reverse of 2 is 4, the reverse of 3 is 12,
    // and the reverse of 0, 6, 9, and 15 leaves each of those numbers unchanged.
    static reverseEndianness(i,n) {
        Util.assert( 0<=i && i<n && 1<=n, `Util.reverseEndianness(): unexpected condition, i===${i}, n===${n}`);
        let result = 0;
        let bit = 1;
        let reversed_bit = n >> 1;
        while ( bit < n ) {
            if ( i & bit )
                result |= reversed_bit;
            bit <<= 1;
            reversed_bit >>= 1;
        }
        Util.assert( bit === n/*this should happen because n should be a power of 2*/, `Util.reverseEndianness(): unexpected condition, n===${n}`);
        return result;
    }
    // Returns angle in [0,2 pi] of the given point in the cartesian plane measured counterclockwise+ with respect to x+
    static angleIn2D(x,y) {
        let hypotenuse = Math.sqrt(x*x+y*y);
        let angle = 0;
        if ( hypotenuse > 0 ) {
            let sine = y / hypotenuse;
            if ( sine>= 1 ) angle = Math.PI/2;
            else if ( sine<=-1) angle = -Math.PI/2;
            else angle = Math.asin(sine);

            if ( x < 0 ) angle = Math.PI - angle;
            if ( angle < 0 ) angle += 2*Math.PI; // ensures angle is in [0,2*M_PI]
        }
        return angle;
    }
}

class StringUtil {
    static numToString( x, decimalPrecision = defaultDecimalPrecision ) {
        let s1 = x.toString();
        let s2 = x.toFixed(decimalPrecision);
        if ( s1.length < s2.length ) return s1;
        else return s2;
    }
    // returns the given string, reversed
    static reverseString(s) {
        let r = "";
        for ( let j = s.length-1; j >= 0; j-- )
            r += s[j];
        return r;
    }
    // returns s repeated n times
    static repeatString(s,n) {
        let r = "";
        for ( let j = 0; j < n; j++ )
            r += s;
        return r;
    }
    // converts an integer to a binary string, padding with zeros at the front
    static intToBinaryString( i, desiredWidth ) {
        let binaryString = i.toString(2/*base 2 for binary*/);
        return StringUtil.repeatString('0',desiredWidth-binaryString.length) + binaryString; // pad with '0's
    }
    // returns number of times the character c occurs in string s
    static countInString(s,c) {
        let r = 0;
        for ( let j = s.length-1; j >= 0; j-- )
            if ( s[j]===c )
                r ++;
        return r;
    }
    // Returns a single multiline string containing the given strings
    // concatenated horizontally and centered vertically.
    // Assumes that none of the given strings are jagged,
    // i.e., assumes that for each given string, all its lines are the same length.
    //
    // For example, calling with arguments ("x = ", "[0,0,1,1]", " * ", "[0]\n[1]\n[0]\n[1]")
    // causes a return of the string
    //    "                [0]\n"
    //   +"x = [0,0,1,1] * [1]\n"
    //   +"                [0]\n"
    //   +"                [1]"
    //
    static concatMultiline(...args) {
        let w = []; // widths of given strings
        let h = []; // heights of given strings
        let max_height = 0;
        for (let s of args) {
            let s2 = s.split('\n');
            h.push( s2.length );
            if ( s2.length > max_height ) max_height = s2.length;
            w.push( s2[0].length );
        }
        let returnValue = "";
        for ( let row = 0; row < max_height; ++row ) {
            for (let stringIndex = 0; stringIndex < args.length; stringIndex ++ ) {
                let s = args[ stringIndex ];
                let rowWithinString = Math.round( row - max_height/2 + h[ stringIndex ]/2 );
                if ( rowWithinString < 0 || rowWithinString >= h[ stringIndex ] ) {
                    // use spaces
                    returnValue += StringUtil.repeatString(' ', w[ stringIndex ] );
                }
                else {
                    //console.log("rowWithinString = " + rowWithinString + ", s =" + s + "END" );
                    returnValue += s.split('\n')[rowWithinString];
                }
            }
            if ( row < max_height-1 )
                returnValue += '\n';
        }
        return returnValue;
    }
}

// Stores a complex number, with real and imaginary components.
class Complex {
    constructor( re = 0, im = 0 ) {
        this._r = re;
        this._i = im;
    }
    toString( decimalPrecision = defaultDecimalPrecision ) {
        if ( this._r === 0 ) {
            if ( this._i === 0 ) {
               return "0";
            }
            else {
               return StringUtil.numToString(this._i,decimalPrecision) + "i";
            }
        }
        else {
            if ( this._i === 0 ) {
               return StringUtil.numToString(this._r,decimalPrecision);
            }
            else {
               let rs = StringUtil.numToString(this._r,decimalPrecision);
               let is = StringUtil.numToString(this._i,decimalPrecision) + "i";
               return is[0]==='-' ? ( rs+is ) : ( rs + "+" + is );
            }
        }
    }
    // returns a deep copy of the complex number
    copy() {
        return new Complex( this._r, this._i );
    }
    conjugate() {
        return new Complex( this._r, - this._i );
    }
    mag() { // magnitude, also known as absolute value or modulus
        return Math.sqrt( this._r * this._r + this._i * this._i );
    }
    magSquared() { // magnitude squared
        return this._r * this._r + this._i * this._i;
    }
    arg() { // argument, also called phase, i.e. the angle of the complex number; always in [0,2 pi]
        return Util.angleIn2D( this._r, this._i );
    }


    // Returns the sum of the two given complex numbers.
    static sum(c1,c2) {
        return new Complex( c1._r+c2._r, c1._i+c2._i );
    }
    // Returns the difference of the two given complex numbers.
    static diff(c1,c2) {
        return new Complex( c1._r-c2._r, c1._i-c2._i );
    }
    // Returns the product of the two given numbers.
    static mult(c1,c2) {
        if ( c1 instanceof Complex ) {
            if ( c2 instanceof Complex ) {
                return new Complex( c1._r*c2._r - c1._i*c2._i, c1._r*c2._i + c1._i*c2._r );
            }
            return new Complex( c1._r * c2, c1._i * c2 );
        }
        else if ( c2 instanceof Complex ) {
            return new Complex( c1 * c2._r, c1 * c2._i );
        }
        return c1 * c2;
    }
}
Complex.i = new Complex(0,1);


// This is a complex matrix, i.e., a matrix containing complex numbers.
// To save on overhead, the complex numbers are stored as consecutive pairs of numbers in a floating point number array.
class CMatrix {
    // allocates space in memory containing zeros
    allocate( numRows, numCols ) {
        this._rows = numRows;
        this._cols = numCols;
        this._m = new Float32Array(
            numRows * numCols
            * 2 // because we're storing a real and imaginary component for each matrix element
        );
    }
    constructor( numRows, numCols ) {
        Util.assert( numRows > 0 && numCols > 0, "CMatrix.constructor(): invalid size requested" );
        this.allocate( numRows, numCols );
    }
    // Gets the value in a cell.
    // row and column indices are zero-based.
    // returns a complex number.
    get(row,col) {
        let j = ( row * this._cols + col )*2;
        return new Complex( this._m[j], this._m[j+1] );
    }
    // Sets the value in a cell.
    // row and column indices are zero-based.
    // The value passed in can be a (real) number or a complex number.
    set(row,col,value) {
        let j = ( row * this._cols + col )*2;
        if ( typeof(value)==='number' ) {
            this._m[j  ] = value; // real component
            this._m[j+1] = 0;
        }
        else if ( typeof(value)==='object' && value instanceof Complex ) {
            this._m[j  ] = value._r;
            this._m[j+1] = value._i;
        }
        else Util.assert(false,"CMatrix.set(): unknown type");
    }
    // Returns a deep copy of the matrix
    copy() {
        let M = new CMatrix( this._rows, this._cols );
        M._m.set( this._m ); // this copies the contents of one to the other
        return M;
    }
    // Returns the transpose of the matrix
    transpose() {
        let M = new CMatrix( this._cols, this._rows );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( c, r, this.get(r,c) );
            }
        }
        return M;
    }
    conjugate() {
        let M = new CMatrix( this._rows, this._cols );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( r, c, this.get(r,c).conjugate() );
            }
        }
        return M;
    }
    // Returns the transpose of the matrix, also known as adjoint matrix or transjugate
    conjugateTranspose() {
        let M = new CMatrix( this._cols, this._rows );
        for ( let r = 0; r < this._rows; ++r ) {
            for ( let c = 0; c < this._cols; ++c ) {
                M.set( c, r, this.get(r,c).conjugate() );
            }
        }
        return M;
    }
    // Returns a complex number equal to the trace (i.e., sum of diagonal elements) of a square matrix
    trace() {
        Util.assert( this._rows === this._cols, "CMatrix.trace(): matrix is not square" );
        let returnValue = new Complex();
        for ( let r = 0; r < this._rows; ++r ) {
            returnValue = Complex.sum( returnValue, this.get(r,r) );
        }
        return returnValue;
    }
    reverseEndianness( actuallyReverseThings=true ) { // should only be called on a row vector, column vector, or matrix whose dimensions are powers of 2
        if ( ! actuallyReverseThings )
            return this; // never mind
        let M = new CMatrix( this._rows, this._cols );
        for ( let r = 0; r < this._rows; ++r ) {
            let r2 = Util.reverseEndianness(r,this._rows);
            for ( let c = 0; c < this._cols; ++c ) {
                let c2 = Util.reverseEndianness(c,this._cols);
                M.set( r2, c2, this.get(r,c) );
            }
        }
        return M;
    }
    // Returns a multiline string, e.g.,
    // a 4x2 matrix might yield "[0,1+2i]\n[1,1   ]\n[0,2i  ]\n[1,0   ]"
    toString(
        // this syntax allows for something similar to named parameters
        { binaryPrefixes=false, decimalPrecision=defaultDecimalPrecision, suppressZeros=true/*makes large binary matrices easier to read*/, charToReplaceSuppressedZero='_' }={}
    ) {
        let arrayOfPrefixStrings = [];
        if ( binaryPrefixes ) {
            let targetWidth = Math.ceil( Math.log2(this._rows) );
            for ( let r = 0; r < this._rows; ++r ) {
                let binaryString = StringUtil.intToBinaryString( r, targetWidth );
                if ( usingTextbookConvention )
                    binaryString = '|' + StringUtil.reverseString( binaryString ) + '>';
                else
                    binaryString = '|' + binaryString + '>';
                arrayOfPrefixStrings.push( binaryString );
            }
        }
        let arrayOfArraysOfStrings = [];
        for ( let r = 0; r < this._rows; ++r ) {
            arrayOfArraysOfStrings.push( [] );
            for ( let c = 0; c < this._cols; ++c ) {
                arrayOfArraysOfStrings[r].push( this.get(r,c).toString(decimalPrecision) );
            }
        }
        let maxMaxWidth = 0;
        for ( let c = 0; c < this._cols; ++c ) {
            let maxWidth = 0;
            for ( let r = 0; r < this._rows; ++r ) {
                let w = arrayOfArraysOfStrings[r][c].length;
                if ( w > maxWidth ) {
                    maxWidth = w;
                    if ( maxWidth > maxMaxWidth ) maxMaxWidth = maxWidth;
                }
            }
            // now we know the max width for this column, so we can pad with spaces
            for ( let r = 0; r < this._rows; ++r ) {
                let w = arrayOfArraysOfStrings[r][c].length;
                arrayOfArraysOfStrings[r][c] += StringUtil.repeatString(' ',maxWidth-w);
            }
        }
        // now we have finished padding all the strings with spaces
        // so we can build the multiline string
        let returnValue = '';
        for ( let r = 0; r < this._rows; ++r ) {
            if ( binaryPrefixes )
                returnValue += arrayOfPrefixStrings[r];
            returnValue += '[';
            for ( let c = 0; c < this._cols; ++c ) {
                if ( suppressZeros && maxMaxWidth===1 && arrayOfArraysOfStrings[r][c]==='0' )
                    returnValue += charToReplaceSuppressedZero;
                else
                    returnValue += arrayOfArraysOfStrings[r][c];
                if ( c < this._cols-1 )
                    returnValue += ',';
            }
            returnValue += ']';
            if ( r < this._rows-1 )
                returnValue += '\n';
        }
        return returnValue;
    }


    // Returns the sum of the two given matrices.
    static sum(a,b) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.sum(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.sum(): incompatible dimensions" );
        let M = a.copy();
        for ( let j = M._m.length-1; j >= 0; j-- )
            M._m[j] += b._m[j];
        return M;
    }

    // Returns the difference of the two given matrices.
    static diff(a,b) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.diff(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.diff(): incompatible dimensions" );
        let M = a.copy();
        for ( let j = M._m.length-1; j >= 0; j-- )
            M._m[j] -= b._m[j];
        return M;
    }
    // Returns the product of the two given matrices,
    // or of a matrix with a scalar.
    static mult( a, b ) {
        Util.assert(a instanceof CMatrix || b instanceof CMatrix,"CMatrix.mult(): wrong type");

        if ( !( a instanceof CMatrix ) ) {
            // swap a and b, so that a will be the matrix and b the scalar
            let tmp = b;
            b = a;
            a = tmp;
        }

        if ( typeof(b)==='number' ) {
            let M = a.copy();
            for ( let j = M._m.length-1; j >= 0; j-- )
                M._m[j] *= b;
            return M;
        }
        else if ( b instanceof Complex ) {
            let M = new CMatrix(a._rows,a._cols);
            for ( let r = 0; r < M._rows; r++ ) {
                for ( let c = 0; c < M._cols; c++ ) {
                    let product = Complex.mult(a.get(r,c),b);
                    M.set(r,c,product);
                }
            }
            return M;
        }
        else if ( b instanceof CMatrix ) {
            Util.assert(a._cols === b._rows, "CMatrix.mult(): matrices have incompatible dimensions" );
            let M = new CMatrix(a._rows,b._cols);
            for ( let r = 0; r < M._rows; r++ ) {
                for ( let c = 0; c < M._cols; c++ ) {
                    let dotProduct = new Complex();
                    for ( let k = 0; k < a._cols; ++k ) {
                        // TODO this line creates 4 instances of Complex that ultimately aren't
                        // needed; this could be optimized by expanding and inlining the math ops.
                        dotProduct = Complex.sum(dotProduct,Complex.mult(a.get(r,k),b.get(k,c)));
                    }
                    M.set(r,c,dotProduct);
                }
            }
            return M;
        }
        else Util.assert(false,"CMatrix.mult(): unknown type");
    }
    // The kronecker product, or tensor product, of two matrices.
    static tensor(a,b,isReversed=false) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.tensor(): wrong type");
        if ( isReversed ) {
            let tmp = a;
            a = b;
            b = tmp;
        }
        let numRows = a._rows * b._rows;
        let numCols = a._cols * b._cols;
        let M = new CMatrix(numRows,numCols);
        for ( let ar = 0; ar < a._rows; ar++ ) {
            for ( let br = 0; br < b._rows; br++ ) {
                for ( let ac = 0; ac < a._cols; ac++ ) {
                    for ( let bc = 0; bc < b._cols; bc++ ) {
                        M.set(
                            ar*b._rows + br,
                            ac*b._cols + bc,
                            Complex.mult( a.get(ar,ac), b.get(br,bc) )
                        );
                    }
                }
            }
        }
        return M;
    }
    // Imagine you want to form the product of many matrices m1 x m2 x ... mN
    // You can obtain this product by calling the below routine with argument [m1,m2,...,mN]
    //
    // Since matrix multiplication is associative, we have a choice of computing the product
    // starting with whatever matrices we like.
    // It turns out to be more efficient to compute the product of smaller matrices first.
    // So, this routine searches through the given list for the consecutive pair
    // of smallest matrices, replaces them with their product, and repeats.
    static naryMult( list ) {
        Util.assert( list.length>0 && list[0] instanceof CMatrix, "CMatrix.naryMult(): invalid input" );
        // let totalCost = 0;
        while ( list.length > 1 ) {
            let lowestCost = 0;
            let indexForLowestCost = -1;
            for ( let i = 0; i < list.length-1; ++i ) {
                // compute the cost of computing the product of the ith and (i+1)th matrices
                let cost = list[i]._rows * list[i]._cols * list[i+1]._cols;
                if ( indexForLowestCost < 0 || cost < lowestCost ) {
                    lowestCost = cost;
                    indexForLowestCost = i;
                }
            }
            // Replace the lowest-cost pair of matrices with a single matrix
            let a = list[ indexForLowestCost ];
            let b = list[ indexForLowestCost + 1 ];
            // replace the ith and (i+1)th matrices with their product
            list.splice( indexForLowestCost, 2, CMatrix.mult(a,b) );
            // totalCost += lowestCost;
        }
        // console.log("totalCost: " + totalCost);
        return list[0];
    }
    // Imagine you want to form the tensor product of many matrices m1 x m2 x ... mN
    // You can obtain this product by calling the below routine with argument [m1,m2,...,mN]
    //
    // Since the tensor product is associative, we have a choice of computing the product
    // starting with whatever matrices we like.
    // It turns out to be more efficient to compute the product of smaller matrices first.
    // So, this routine searches through the given list for the consecutive pair
    // of smallest matrices, replaces them with their product, and repeats.
    static naryTensor( list, isReversed=false ) {
        Util.assert( list.length>0 && list[0] instanceof CMatrix, "CMatrix.naryTensor(): invalid input" );
        if ( isReversed ) {
            list.reverse();
        }
        // let totalCost = 0;
        while ( list.length > 1 ) {
            let lowestCost = 0;
            let indexForLowestCost = -1;
            for ( let i = 0; i < list.length-1; ++i ) {
                // compute the cost of computing the product of the ith and (i+1)th matrices
                let cost = list[i]._rows * list[i]._cols * list[i+1]._rows * list[i+1]._cols;
                if ( indexForLowestCost < 0 || cost < lowestCost ) {
                    lowestCost = cost;
                    indexForLowestCost = i;
                }
            }
            // Replace the lowest-cost pair of matrices with a single matrix
            let a = list[ indexForLowestCost ];
            let b = list[ indexForLowestCost + 1 ];
            // replace the ith and (i+1)th matrices with their product
            list.splice( indexForLowestCost, 2, CMatrix.tensor(a,b) );
            // totalCost += lowestCost;
        }
        // console.log("totalCost: " + totalCost);
        return list[0];
    }
    // TODO This should be improved using exponentiation by squaring or binary exponentiation, and something similar could be done for a power() method that raises a matrix to a given exponent
    static tensorPower( matrix, exponent ) {
        Util.assert( exponent>0 && matrix instanceof CMatrix, "CMatrix.naryTensor(): invalid input" );
        let list = [];
        for ( let i = 0; i < exponent; ++i ) {
            list.push( matrix );
        }
        return CMatrix.naryTensor( list );
    }

    // If the caller needs to know Trace(A * B),
    // this subroutine saves time by only computing the diagonal elements of the matrix product.
    // This is equivalent to taking the transpose of one of the matrices,
    // doing element-wise multiplication, and adding up all the elements in the resulting matrix.
    //
    function traceOfMatrixProduct( A, B ) {
        Util.assert(A._cols === B._rows, "CMatrix.traceOfMatrixProduct(): matrices have incompatible dimensions" );
        Util.assert(A._rows === B._cols, "CMatrix.traceOfMatrixProduct(): matrix product is not square, hence trace is not defined" );
        let product_size = A._rows;
        let returnValue = new Complex();
        for ( let ii = 0; ii < product_size; ii++ ) {
            let dotProduct = new Complex();
            for ( let k = 0; k < A._cols; ++k ) {
                // TODO this line creates 4 instances of Complex that ultimately aren't
                // needed; this could be optimized by expanding and inlining the math ops.
                dotProduct = Complex.sum(dotProduct,Complex.mult(A.get(ii,k),B.get(k,ii)));
            }
            returnValue = Complex.sum( returnValue, dotProduct );
        }
        return returnValue;
    }

    // returns true if the given matrices are approximately equal, within the given tolerance
    static approximatelyEqual(a,b,tolerance=precisionForApproximateComparison,printMessage=true) {
        Util.assert(a instanceof CMatrix && b instanceof CMatrix,"CMatrix.approximatelyEqual(): wrong type");
        Util.assert(a._rows === b._rows && a._cols === b._cols, "CMatrix.approximatelyEqual(): incompatible dimensions" );
        for ( let j = a._m.length-1; j >= 0; j-- ) {
            let delta = Math.abs( a._m[j] - b._m[j] );
            if ( delta > tolerance ) {
                if ( printMessage ) {
                    console.log(`CMatrix.approximatelyEqual(): difference of ${delta} found`);
                }
                return false;
            }
        }
        return true;
    }


    // Creates and returns a matrix by copying the contents of the given array of arrays,
    // which can contain numbers or complex numbers.
    // Assumes that the given array is not jagged.
    static create( arrayOfArrays ) {
        let numRows = arrayOfArrays.length;
        let numCols = arrayOfArrays[0].length;
        let M = new CMatrix( numRows, numCols );
        for ( let j = 0; j < numRows; ++j ) {
            for ( let k = 0; k < numCols; ++k ) {
                M.set( j, k, arrayOfArrays[j][k] );
            }
        }
        return M;
    }
    // Creates a nx1 size matrix
    static createColVector( array ) {
        return this.create( array.map( x => [ x ] ) );
    }
    // Creates a 1xn size matrix
    static createRowVector( array ) {
        return this.create( [ array ] );
    }
    // Returns an identity matrix of the given size
    static identity( numRows ) {
        let M = new CMatrix( numRows, numRows );
        for ( let k = 0; k < numRows; ++k )
            M.set(k,k,1);
        return M;
    }
}

class Sim { // Simulator

    static GlobalPhase( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let globalPhaseChange = new Complex( Math.cos(angleInRadians), Math.sin(angleInRadians) );
        return CMatrix.create([[globalPhaseChange,0],[0,globalPhaseChange]]);
    }
    // Note that
    //     Phase(angle) * GlobalPhase( -angle/2 ) = RZ( angle )
    //     Phase(angle) = RZ( angle ) * GlobalPhase( angle/2 )
    static Phase( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let phaseChange = new Complex( Math.cos(angleInRadians), Math.sin(angleInRadians) );
        return CMatrix.create([[1,0],[0,phaseChange]]);
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli X gate (also called NOT gate)
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RX(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.X.toString());
    //
    static RX( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,0), new Complex(0,-sine) ],
            [ new Complex(0,-sine),  new Complex(cosine,0) ],
        ] );
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli Y gate
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RY(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.Y.toString());
    //
    static RY( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,0), new Complex(-sine,0) ],
            [ new Complex(sine,0),  new Complex(cosine,0) ],
        ] );
    }
    // Returns a 2x2 matrix that rotates around an axis of the Bloch sphere.
    // With a 180 degree angle, this is equivalent to a Pauli Z gate
    // but differs by a global phase.
    // More particularly, the following print statements should output the same thing:
    //   console.log(CMatrix.mult(Sim.RZ(180),Sim.GlobalPhase(90)).toString());
    //   console.log(Sim.Z.toString());
    //
    static RZ( angleInDegrees ) {
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,-sine), new Complex(0,0) ],
            [ new Complex(0,0),  new Complex(cosine,sine) ],
        ] );
    }
    // This rotates around the given vector by an angle in radians equal to the magnitude of the given vector.
    // This way of encoding the angle in the vector of the axis of rotation might seem strange,
    // but it means that the output is continuous in all 3 input variables and therefore easier to optimize,
    // which would not be the case with a parametrization where the angle is separate from the vector components of the axis.
    // (To see why, consider the latter parametrization, and imagine what would happen as the input shifts
    // from (ax,ay-epsilon,az,angle) to (ax,ay+epsilon,az,angle).
    // This would result in a 180 degree change of axis direction and a discontinuous change in output.
    // The same kind of change of axis direction in the first parametrization would require the angle to pass through zero,
    // avoiding a discontinuity in the output.)
    //
    // For the definition of the matrix, see
    //     https://arxiv.org/abs/2104.14875
    //     Hiroshi C. Watanabe, Rudy Raymond, Yu-ya Ohnishi, Eriko Kaminishi, Michihiko Sugawara
    //     Optimizing Parameterized Quantum Circuits with Free-Axis Selection
    // in particular equation (1) on page 4.
    // See also the documentation for the RVGate in Qiskit
    //     https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.RVGate
    // although, at the time of writing, that documentation contains typos.
    // See also the source code for the RVGate in Qiskit
    //     https://github.com/Qiskit/qiskit/blob/stable/0.46/qiskit/circuit/library/generalized_gates/rv.py
    //
    // If (ax,ay,az) is proportional to (1,0,0), or to (0,1,0), or to (0,0,1),
    // the result is equivalent to RX, RY, or RZ, respectively.
    static RotFreeAxis( ax, ay, az ) {
        let magSquared = ax*ax + ay*ay + az*az;
        if ( magSquared === 0 ) {
            return Sim.I;
        }
        let angleInRadians = Math.sqrt( magSquared );
        ax /= angleInRadians;
        ay /= angleInRadians;
        az /= angleInRadians;
        let halfAngle = angleInRadians / 2;
        let sine = Math.sin( halfAngle );
        let cosine = Math.cos( halfAngle );
        return CMatrix.create( [
            [ new Complex(cosine,-az*sine), new Complex(-ay*sine,-ax*sine) ],
            [ new Complex(ay*sine,-ax*sine),  new Complex(cosine,az*sine) ],
        ] );
    }
    static RotFreeAxisAngle( ax, ay, az, angleInDegrees ) { // rotates around the given axis by the given angle
        let angleInRadians = angleInDegrees / 180.0 * Math.PI;
        let magSquared = ax*ax + ay*ay + az*az;
        if ( magSquared === 0 || angleInDegrees === 0 ) {
            return Sim.I;
        }
        let k = angleInRadians / Math.sqrt( magSquared );
        return Sim.RotFreeAxis( ax * k, ay * k, az * k );
    }
    // Returns a matrix for swapping wires i and j in a quantum circuit with n wires.
    // i and j are zero-based, i.e., they are between 0 and (n-1).
    // The matrix that is returned has size (2**n)x(2**n)
    static SWAP(i,j,n) {
        Util.assert( 0<=i && i<n && 0<=j && j<n, "Sim.SWAP(): invalid indices" );
        Util.assert( i!=j, "Sim.SWAP(): indices are unexpectedly equal" );
        let matrixSize = 2 ** n;
        if ( i === j ) {
            return CMatrix.identity( matrixSize );
        }
        let M = new CMatrix( matrixSize, matrixSize );

        if ( usingTextbookConvention ) {
            // inverting the wire indices like this is equivalent to calling reverseEndianness() on the matrix just before returning it, but this is more efficient
            i = n-1 - i;
            j = n-1 - j;
        }

        // define stuff for operating on bits
        let mask_i = 1 << i;
        let mask_j = 1 << j;
        let antimask = ~( mask_i | mask_j );

        for ( let r = 0; r < matrixSize; ++r ) {
            let c = r;

            // BEGIN: swap the ith and jth bits of c
            let extracted_bit_i = c & mask_i;
            let extracted_bit_j = c & mask_j;
            c &= antimask; // turns off bits i and j
            if ( extracted_bit_i !== 0 ) c |= mask_j; // turns on bit j
            if ( extracted_bit_j !== 0 ) c |= mask_i; // turns on bit i
            // END

            M.set(r,c,1);
        }
        return M;
    }
    // Given a 4x4 matrix, which operates on two qubits q0 and q1,
    // this routine modifies it so that it will operate on the ith and jth qubits
    // of an n-qubit circuit.
    // The matrix that is returned has size (2**n)x(2**n)
    // For example, passing in arguments (m,1,0,2)
    // returns an 'upside-down' version of the original matrix.
    static expand4x4ForNWires(m/*a 4x4 matrix*/,i,j,n/*number of qubits in the circuit*/) {
        Util.assert( 0<=i && i<n && 0<=j && j<n && i!=j, "Sim.expand4x4ForNWires(): invalid indices" );
        Util.assert( m._rows===m._cols && m._rows===4, "Sim.expand4x4ForNWires(): invalid size" );

        // Step 1: turn the matrix upside down, if necessary
        let m1 = null;
        if ( i > j ) {
            //
            //              +----+                +---+
            //        q_0 --|    |--     q_0 --X--|   |--X--
            //              | m1 |    =        |  | m |  |
            //        q_1 --|    |--     q_1 --X--|   |--X--
            //              +----+                +---+
            //
            //              +----+                +---+
            // q_i' = q_j --|    |--     q_j --X--|   |--X--
            //              | m1 |    =        |  | m |  |
            // q_j' = q_i --|    |--     q_i --X--|   |--X--
            //              +----+                +---+
            //
            m1 = CMatrix.naryMult([ Sim.SWAP_2, m, Sim.SWAP_2 ]);
            let tmp = i;
            i = j;
            j = tmp;
            Util.assert(i<j,"Sim.expand4x4ForNWires(): unexpected condition");
        }
        else {
            m1 = m.copy();
        }

        // Step 2: account for wires in between i and j
        let m2 = null;
        let numInnerWires = j-i-1;
        if ( numInnerWires > 0 ) {
            //
            //       q_0 --+----+--           q_0 -----+----+-----
            //             |    |                      | m1 |
            //       q_1 --|    |--           q_1 --X--+----+--X--
            //             |    |                   |          |
            //       ... --|    |--           ... --|----------|--
            //             | m2 |    =              |          |
            //             |    |             ...
            //             |    |                   |          |
            //       ... --|    |--           ... --|----------|--
            //             |    |                   |          |
            //   q_{j-i} --+----+--       q_{j-i} --X----------X--
            //
            let swapStep = CMatrix.tensor( Sim.SWAP(0,numInnerWires,numInnerWires+1), Sim.I, usingTextbookConvention );
            m2 = CMatrix.naryMult( [
                swapStep,
                CMatrix.tensor( CMatrix.identity(2**numInnerWires), m1, usingTextbookConvention ),
                swapStep
            ] );
        }
        else {
            m2 = m1;
        }

        // Step 3: if there are wires before i, and/or after j,
        // we must perform a tensor product with an appropriately sized identity matrix,
        // either before and/or after m2, respectively.
        // Rather than do these tensor products separately here,
        // we put the relevant matrices in a list and let naryTensor()
        // perform the tensor products in the optimal associative order.
        //
        let listOfMatrices = [ m2 ];
        let numWiresBefore = i;
        if ( numWiresBefore > 0 ) {
            listOfMatrices.push( CMatrix.identity(2**numWiresBefore) ); // add to end of list
        }
        let numWiresAfter = n-1-j;
        if ( numWiresAfter > 0 ) {
            listOfMatrices.unshift( CMatrix.identity(2**numWiresAfter) ); // insert at beginning of list
        }
        let m3 = CMatrix.naryTensor( listOfMatrices, usingTextbookConvention  );

        return m3;
    }

    // Returns a new state vector.
    // Avoids computing an explicit matrix of size (2**n)x(2**n), saving a lot of memory and time.
    //
    // Imagine the state vector partitioned into contiguous blocks of equal size,
    // with each block partitioned into two half blocks.
    // The below code steps through the blocks, and within each block, for each i,
    // it will take the ith amplitude of the first half block and the ith amplitude
    // of the second half block, store those two amplitudes in a temporary vector
    // (this is the "collect" step, since it collects the amplitudes into the temporary vector),
    // apply the 2x2 matrix to that temporary vector, and store the resulting amplitudes
    // back in the ith positions of the half blocks (the "scatter" step).
    //
    // The below code is similar to the code in Quirk ( https://github.com/Strilanc/Quirk/ ,
    // src/math/Matrix.js , applyToStateVectorAtQubitWithControls() )
    // and also similar to the pseudocode in Figure 6.1 of the book by Viamontes et al.
    // (Viamontes, G. F., Markov, I. L., & Hayes, J. P. (2009) "Quantum circuit simulation")
    // Viamontes et al. call this algorithm "qubit-wise multiplication".
    //
    // To compare with Quirk's version of the code, it helps to know that Quirk's source code
    // calls the tempVector a 'chunk', and it uses different names for several variables,
    // listed below.  Also, our version has indices and sizes of things in complex numbers
    // (i.e., in amplitudes), whereas Quirk's corresponding quantities are in floats and
    // are therefore doubled.
    //
    //     Some quantities in our code, and the corresponding quantities in Quirk's code:
    //         sizeOfHalfBlock (in complex numbers) is (strideLength (in floats))/2
    //         sizeOfBlock (in complex numbers) is (strideChunkSize (in floats))/2
    //         indexOfStartOfBlock (in complex numbers) is (strideChunkStart (in floats))/2
    //         offsetWithinBlock (in complex numbers) is (strideOffset (in floats))/2
    //
    // Viamontes et al., Figure 6.1, appears to be the same algorithm. The inner "for" loop
    // in it performs the "collect" step, and the line of code immediately following,
    // which uses slice notation (res[a:...:gap]), performs the "scatter" step.
    // The 'gap' variable in Viamontes et al.'s version is sizeOfHalfBlock in our code.
    // However, Viamontes et al., Figure 6.1 also contains errors: it mentions a
    // "group_factor" that is undefined, and contains a stray closing brace.
    // There are other things about it that are confusing which I haven't
    // fully analyzed.  Finally, Viamontes et al.'s version has no support for control bits.
    //
    static transformStateVectorWith2x2(
        m, // a 2x2 matrix
        i, // index of wire on which to apply m
        n, // number of qubits in the circuit
        stateVector, // a matrix of size (2**n)x1, i.e. a column vector
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        Util.assert( 0<=i && i<n, "Sim.transformStateVectorWith2x2(): invalid index" );
        Util.assert( m._rows===m._cols && m._rows===2, "Sim.transformStateVectorWith2x2(): invalid size" );
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.transformStateVectorWith2x2(): state vector has invalid size" );

        let inclusionMask = 0;
        let desiredValueMask = 0;
        for ( let iter of listOfControlBits ) {
            let [wireIndex,flag] = iter;
            if ( usingTextbookConvention )
                wireIndex = n-1 - wireIndex;
            let bit = 1 << wireIndex;
            inclusionMask |= bit;
            if ( flag )
                desiredValueMask |= bit;
        }

        if ( usingTextbookConvention )
            i = n-1 - i;
        let tempVector = new CMatrix(2,1);
        let sizeOfHalfBlock = 1 << i; // could be 1, 2, 4, ...
        let sizeOfBlock = sizeOfHalfBlock * 2; // could be 2, 4, 8 ...
        let result = stateVector.copy();
        for ( let indexOfStartOfBlock = 0; indexOfStartOfBlock < stateVector._rows; indexOfStartOfBlock += sizeOfBlock ) {
            for ( let offsetWithinBlock = 0; offsetWithinBlock < sizeOfHalfBlock; offsetWithinBlock ++ ) {
                Util.assert( indexOfStartOfBlock | offsetWithinBlock === indexOfStartOfBlock + offsetWithinBlock, "Sim.transformStateVectorWith2x2(): unexpected numbers" );
                let stateIndex1 = indexOfStartOfBlock | offsetWithinBlock;
                if ( (stateIndex1 & inclusionMask) !== desiredValueMask )
                    continue;

                let stateIndex2 = stateIndex1 + sizeOfHalfBlock;

                // Collect inputs into a small contiguous vector.
                tempVector.set( 0, 0, stateVector.get( stateIndex1, 0 ) );
                tempVector.set( 1, 0, stateVector.get( stateIndex2, 0 ) );

                let transformedVector = CMatrix.mult( m, tempVector );

                // Scatter outputs.
                result.set( stateIndex1, 0, transformedVector.get( 0, 0 ) );
                result.set( stateIndex2, 0, transformedVector.get( 1, 0 ) );
            }
        }
        return result;
    }
    // Returns a new state vector.
    // Avoids computing an explicit swap matrix of size (2**n)x(2**n), saving a lot of memory and time.
    static transformStateVectorWithSwap(
        i, // index of 1st wire on which to apply the swap
        j, // index of 2nd wire on which to apply the swap
        n, // number of qubits in the circuit
        stateVector, // a matrix of size (2**n)x1, i.e. a column vector
        listOfControlBits = [] // a list of pairs of the form [wire_index, flag] where 0<=wire_index<n and flag is true for a control bit and false for an anti-control bit
    ) {
        Util.assert( 0<=i && i<n && 0<=j && j<n, "Sim.transformStateVectorWithSwap(): invalid indices" );
        Util.assert( i!=j, "Sim.transformStateVectorWithSwap(): indices are unexpectedly equal" );
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.transformStateVectorWithSwap(): state vector has invalid size" );

        let result = stateVector.copy();
        if ( i === j ) {
            return result;
        }

        let inclusionMask = 0;
        let desiredValueMask = 0;
        for ( let iter of listOfControlBits ) {
            let [wireIndex,flag] = iter;
            if ( usingTextbookConvention )
                wireIndex = n-1 - wireIndex;
            let bit = 1 << wireIndex;
            inclusionMask |= bit;
            if ( flag )
                desiredValueMask |= bit;
        }

        if ( usingTextbookConvention ) {
            i = n-1 - i;
            j = n-1 - j;
        }
        if ( i > j ) {
            let tmp = i;
            i = j;
            j = tmp;
        }
        let numStates = 2 ** n;

        // define stuff for operating on bits
        let mask_i = 1 << i;
        let mask_j = 1 << j;
        let antimask = ~( mask_i | mask_j );

        for ( let r1 = 0; r1 < numStates; ++r1 ) {
            if ( (r1 & inclusionMask) !== desiredValueMask )
                continue;

            let r2 = r1;

            let ithBit = (r2 >> i) & 1;
            let jthBit = (r2 >> j) & 1;
            // If the ith and jth bits are both 0 or both 1, we don't need to swap rows.
            // If the two bits have different values, we do want to swap rows r1 and r2.
            // But we don't want to swap those rows twice.
            // So we only swap when we encounter the case where the ith bit is 1 and the jth is 0.
            if ( ithBit===1 && jthBit===0 ) {
                r2 &= antimask; // turns off bits i and j
                r2 |= mask_j; // turns on bit j

                result.set(r2,0,stateVector.get(r1,0));
                result.set(r1,0,stateVector.get(r2,0));
            }
        }
        return result;
    }

    // Returns the given number i with its bits rearranged,
    // so that the 0th bit of i is in position a[0],
    // the 1st bit of i is in position a[1],
    // etc.
    // Negative positions in the array a are ignored.
    // For example, rearrangeBits(i,[1,0]) returns the two least-significant bits of i, swapped, and none of the other bits.
    // As another example, rearrangeBits(i,[0,1,2])) returns only the three least-significant bits of i, with their positions unchanged.
    // As another example, rearrangeBits(i,[3,0,1,2])) returns only the four least-significant bits of i, shifted left (to one position more significant)
    // and wrapped around.
    static rearrangeBits( i, a /* an array of new positions */ ) {
        let returnValue = 0;
        for ( let position = 0; position < a.length; ++position ) {
            if ( a[position] >= 0 )
                returnValue |= ( (i >> position) & 1 ) << a[position];
        }
        return returnValue;
    }

    // Consider a 16x16 density matrix M defined for 4 qubits, numbered 0 to 3.
    // The caller could do
    //     partialTrace( 4, M, [0,1], true );
    // to trace out qubits 0 and 1, keeping 2 and 3, and returning a 4x4 matrix.
    // Or, the caller could do
    //     partialTrace( 4, M, [2,3], false );
    // which would be equivalent.
    //
    static partialTrace(
        n, // number of qubits in the circuit
        inputMatrix, // a matrix of size (2**n)x(2**n)
        qubitArray, // an array of values in the range 0 to n-1, each representing a qubit
        arraySpecifiesQubitsToTraceOut // if false, the array specifies the qubits to keep (i.e., marginal qubits)
    ) {
        let twoN = 2**n;
        Util.assert( inputMatrix._rows===twoN && inputMatrix._cols===twoN, "Sim.partialTrace(): input matrix has invalid size" );
        Util.assert( 0 < qubitArray.length && qubitArray.length < n, "Sim.partialTrace(): array of qubit indices has invalid size" );

        const _qubitArray = [...new Set(qubitArray)].sort((a, b) => a - b); // remove duplicates, and sort in ascending order
        Util.assert( 0 <= _qubitArray[0] && _qubitArray[_qubitArray.length-1] < n, "Sim.partialTrace(): invalid qubit index" );

        // Compute an array of complementary indices, containing all the indices in [0,n-1] that are not already in _qubitArray
        let _arrayOfOtherQubits = [];
        let array_index = 0;
        for ( let index = 0; index < n; index ++ ) {
            if ( array_index < _qubitArray.length ) {
                if ( index < _qubitArray[ array_index ] ) {
                    _arrayOfOtherQubits.push( index );
                }
                else if ( index === _qubitArray[ array_index ] ) {
                    array_index ++;
                }
            }
            else {
                _arrayOfOtherQubits.push( index );
            }
        }
        Util.assert( _qubitArray.length + _arrayOfOtherQubits.length === n, "Sim.partialTrace(): error computing complementary set of indices" );


        let qubitsToTraceOut = [];
        let qubitsToKeep = []; // the marginal qubits
        if ( arraySpecifiesQubitsToTraceOut ) {
            qubitsToTraceOut = _qubitArray;
            qubitsToKeep = _arrayOfOtherQubits;
        }
        else {
            qubitsToKeep = _qubitArray;
            qubitsToTraceOut = _arrayOfOtherQubits;
        }


        let numQubitsToTraceOut = qubitsToTraceOut.length;
        let numQubitsToKeep = qubitsToKeep.length;
        let twoOut = 2 ** numQubitsToTraceOut;
        let twoKeep = 2 ** numQubitsToKeep;
        let outputMatrix = new CMatrix(twoKeep,twoKeep);

        for (
            let shared_bits = 0; // bits common to input_row and input_col
            shared_bits < twoOut;
            shared_bits ++
        ) {
            let shared_bits_shifted = Sim.rearrangeBits( shared_bits, qubitsToTraceOut );
            for ( let output_row = 0; output_row < twoKeep; output_row ++ ) {
                let input_row = shared_bits_shifted | Sim.rearrangeBits( output_row, qubitsToKeep );
                for ( let output_col = 0; output_col < twoKeep; output_col ++ ) {
                    let input_col = shared_bits_shifted | Sim.rearrangeBits( output_col, qubitsToKeep );
                    // The next line, in pseudocode, could be written more simply as
                    //    outputMatrix[output_row,output_col] += inputMatrix[input_row,input_col]
                    outputMatrix.set( output_row, output_col, Complex.sum( outputMatrix.get(output_row,output_col), inputMatrix.get(input_row,input_col) ));
                }
            }
        }
        return outputMatrix;
    }

    // Returns a matrix of size (2**n)x(2**n)
    static computeDensityMatrix(
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computeDensityMatrix(): state vector has invalid size" );
        return CMatrix.mult( stateVector, stateVector.conjugateTranspose() );
    }
    // Implements partial trace down to one qubit. Returns a 2x2 matrix
    // Should be equivalent to partialTrace( n, densityMatrix, [i], false );
    static computeReducedDensityMatrixForOneQubit(
        i, // the qubit of interest; we trace out the other qubits
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( 0<=i && i<n, "Sim.computeReducedDensityMatrixForOneQubit(): invalid index" );
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computeReducedDensityMatrixForOneQubit(): density matrix has invalid size" );

        let rdm = new CMatrix(2,2); // reduced density matrix; a 2x2 matrix

        let MAX = twoN >> 1;
        let mask0 = (1<<i)-1; // results in a string of i 1s. E.g., if i=4, this results in 1111 in base 2
        let mask1 = ((1<<(n-i-1))-1)<<i; // results in a string of (n-i-1) 1s, shifted left by (i)
        Util.assert( mask1+mask0===MAX-1, "Sim.computeReducedDensityMatrixForOneQubit(): error with masks" );
        for (
            let shared_bits = 0; // bits common to input_row and input_col
            shared_bits < MAX;
            shared_bits ++
        ) {
            let shared_bits_shifted
                // introduce a space for the ith bit to be added from the output_row or output_col
                = ((shared_bits & mask1)<<1) | (shared_bits & mask0);
            for ( let output_row = 0; output_row < 2; output_row ++ ) {
                let input_row = shared_bits_shifted | (output_row<<i);
                for ( let output_col = 0; output_col < 2; output_col ++ ) {
                    let input_col = shared_bits_shifted | (output_col<<i);
                    // The next line, in pseudocode, could be written more simply as
                    //    rdm[output_row,output_col] += densityMatrix[input_row,input_col]
                    rdm.set( output_row, output_col, Complex.sum( rdm.get(output_row,output_col), densityMatrix.get(input_row,input_col) ));
                }
            }
        }
        return rdm;
    }
    // Implements partial trace down to two qubits. Returns a 4x4 matrix
    // Should be equivalent to partialTrace( n, densityMatrix, [i,j], false );
    static computeReducedDensityMatrixForTwoQubits(
        i,j, // the two qubits of interest; we trace out the other qubits
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        if ( i > j ) {
            // swap
            let tmp = i;
            i = j;
            j = tmp;
        }
        let twoN = 2**n;
        Util.assert( 0<=i && i<j && j<n, "Sim.computeReducedDensityMatrixForTwoQubits(): invalid indices" );
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computeReducedDensityMatrixForTwoQubits(): density matrix has invalid size" );

        let rdm = new CMatrix(4,4); // reduced density matrix; a 4x4 matrix

        let MAX = twoN >> 2;
        let mask0 = (1<<i)-1; // results in a string of i 1s. E.g., if i=4, this results in 1111 in base 2
        let mask1 = ((1<<(j-i-1))-1)<<i; // results in a string of (j-i-1) 1s, shifted left by i.
        let mask2 = ((1<<(n-j-1))-1)<<(j-1); // results in a string of (n-j-1) 1s, shifted left by (j-1)
        Util.assert( mask2+mask1+mask0===MAX-1, "Sim.computeReducedDensityMatrixForTwoQubits(): error with masks" );
        for (
            let shared_bits = 0; // bits common to input_row and input_col
            shared_bits < MAX;
            shared_bits ++
        ) {
            let shared_bits_shifted
                // introduce two spaces for the ith and jth bits to be added from the output_row or output_col
                = ((shared_bits & mask2)<<2) | ((shared_bits & mask1)<<1) | (shared_bits & mask0);
            for ( let output_row = 0; output_row < 4; output_row ++ ) {
                let input_row = shared_bits_shifted | ((output_row&2)<<(j-1)) | ((output_row&1)<<i);
                for ( let output_col = 0; output_col < 4; output_col ++ ) {
                    let input_col = shared_bits_shifted | ((output_col&2)<<(j-1)) | ((output_col&1)<<i);
                    // The next line, in pseudocode, could be written more simply as
                    //    rdm[output_row,output_col] += densityMatrix[input_row,input_col]
                    rdm.set( output_row, output_col, Complex.sum( rdm.get(output_row,output_col), densityMatrix.get(input_row,input_col) ));
                }
            }
        }
        return rdm;
    }
    // Implements partial trace to trace out one qubit. Returns a matrix with half as many rows and half as many columns.
    // Should be equivalent to partialTrace( n, densityMatrix, [i], true );
    static computeReducedDensityMatrixForOneLessQubit(
        i, // the qubit to trace out
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( 0<=i && i<n, "Sim.computeReducedDensityMatrixForOneLessQubit(): invalid index" );
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computeReducedDensityMatrixForOneLessQubit(): density matrix has invalid size" );

        let rdm = new CMatrix(twoN/2,twoN/2); // reduced density matrix

        let mask_i = 1 << i;
        let mask_low = mask_i - 1;
        let mask_high = (twoN-1) - mask_i - mask_low;
        for ( let input_row = 0; input_row < twoN; input_row ++ ) {
            let traced_bit = (input_row & mask_i) >> i;
            let output_row = ((input_row & mask_high)>>1) | (input_row & mask_low);
            for ( let input_col = 0; input_col < twoN; input_col ++ ) {
                if ( (input_col & mask_i)>>i === traced_bit ) {
                    let output_col = ((input_col & mask_high)>>1) | (input_col & mask_low);

                    // The next line, in pseudocode, could be written more simply as
                    //    rdm[output_row,output_col] += densityMatrix[input_row,input_col]
                    rdm.set( output_row, output_col, Complex.sum( rdm.get(output_row,output_col), densityMatrix.get(input_row,input_col) ));
                }
            }
        }

        return rdm;
    }
    // returns an object containing statistics
    static computeStatsFor2x2DensityMatrix(
        dm // a 2x2 density matrix for a single qubit
    ) {
        Util.assert( dm._rows===2 && dm._cols===2, "Sim.computeStatsFor2x2DensityMatrix(): matrix is not 2x2");
        /*
        Assume the local state of the qubit is pure and therefore can be expressed as
           |psi> = alpha |0> + e^(i phase) (1-alpha^2)^0.5 |1>
                 = cos(theta/2) |0> + e^(i phase) sin(theta/2) |1>
        where alpha is nonnegative real, theta is in [0,pi], phase is in [0,2pi]
        Note that we're assuming that we could apply a global phase to make the complex amplitude in front of |0> nonnegative real.
        Then, in the Bloch sphere space, we will have
           x = (sin theta)(cos phase)
           y = (sin theta)(sin phase)
           z = (cos theta)
        and the 2x2 density matrix for the qubit will be

           |psi><psi| = [ cos(theta/2)             ] * [ cos(theta/2)   e^(-i phase) sin(theta/2) ]
                        [ e^(i phase) sin(theta/2) ]

                      = [ cos^2(theta/2)                          e^(-i phase) sin(theta/2) cos(theta/2) ]
                        [ e^(i phase) sin(theta/2) cos(theta/2)   sin^2(theta/2)                         ]

                      = [ (1+cos theta)/2                                     (cos phase - i sin phase)((1-cos^2(theta))^0.5)/2 ]
                        [ (cos phase + i sin phase)((1-cos^2(theta))^0.5)/2   (1-cos theta)/2                                   ]

                      = [ (1+z)/2                                  (cos phase - i sin phase)(sin theta)/2 ]
                        [ (cos phase + i sin phase)(sin theta)/2   (1-z)/2                                ]

                      = [ (1+z)/2       (x - i y)/2 ]
                        [ (x + i y)/2   (1-z)/2     ]

        which hints at how to recover x, y, z from the entries of the 2x2 matrix.
        It turns out that, even if the qubit is in a mixed state,
        its 2x2 reduced density matrix has the same form as the last expression above.
        See Nielsen and Chuang, page 105, exercise 2.72, about "Bloch sphere for mixed states".
        The general form for a 2x2 density matrix, even for a mixed state, is (1/2)(I_2 + x X + y Y + z Y),
        where I_2 is the 2x2 identity matrix, (x,y,z) are the coordinates of the Bloch vector, (X,Y,Z) are the Pauli matrices,
        and the diagonal elements of the density matrix are real-valued and sum to 1, and the off-diagonal elements are conjugate.
        */

        let [ar, ai, br, bi, cr, ci, dr, di] = dm._m;
        // TODO you should assert that all these equalities are approximately true: ai===0, di===0, br===cr, bi=== -ci
        let x = br + cr;
        let y = ci - bi;
        let z = ar - dr;
        let radius = Math.sqrt(x*x + y*y + z*z);
        let phase = Util.angleIn2D(x,y);
        let theta = Util.angleIn2D(z,Math.sqrt(x*x+y*y));
        let probabilityOfOne = (1-z)/2;
        let purity = CMatrix.mult( dm, dm ).trace();
        let cosine_theta_over_2 = Math.cos(theta/2);
        let sine_theta_over_2 = Math.sin(theta/2);
        let psi_amplitude_0 = new Complex( cosine_theta_over_2, 0 );
        let psi_amplitude_1 = new Complex( Math.cos(phase)*sine_theta_over_2, Math.sin(phase)*sine_theta_over_2 );

        let vonNeumannEntropy = 0; // will be in the range [0,1]
        let lambda = Sim.eigendecomposition( dm );
        if ( lambda === null ) {
            // the eigendecomposition failed
            const ERROR_VALUE = -0.1;
            vonNeumannEntropy = ERROR_VALUE;
        }
        else {
            for ( let i = 0; i < lambda.length; ++i ) {
                if ( lambda[i] > 0 )
                    vonNeumannEntropy -= lambda[i] * Math.log2( lambda[i] );
            }
        }

        return {
            x:x, y:y, z:z, radius:radius, phase:phase, theta:theta, // these specify the Bloch vector
            probabilityOfOne:probabilityOfOne,
            purity:purity,
            linearEntropy:(1-purity._r),
            vonNeumannEntropy:vonNeumannEntropy,
            psi_amplitude_0:psi_amplitude_0, psi_amplitude_1:psi_amplitude_1
        };
    }
    // returns an array of objects, one for each qubit
    static analyzeEachQubit(
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.analyzeEachQubit(): density matrix has invalid size" );

        let results = [];
        for ( let i = 0; i < n; ++i ) {
            let RDM = Sim.computeReducedDensityMatrixForOneQubit(i,n,densityMatrix);
            let S = Sim.computeStatsFor2x2DensityMatrix( RDM );
            S.reducedDensityMatrix = RDM;
            results.push( S );
        }
        return results;
    }
    static printAnalysisOfEachQubit(
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.printAnalysisOfEachQubit(): state vector has invalid size" );
        let DM = Sim.computeDensityMatrix( n, stateVector );
        console.log("Density matrix is\n" + DM.toString({decimalPrecision:2}) + "\nwith trace " + DM.trace() + " and purity " + (CMatrix.mult(DM,DM)).trace() );
        let stats = Sim.analyzeEachQubit(n,DM);
        for ( let i = 0; i < n; ++i ) {
            let RDM = stats[i].reducedDensityMatrix;
            console.log(StringUtil.concatMultiline(`Reduced density matrix for qubit ${i} is `, RDM.toString(), " with trace " + RDM.trace() + " and purity " + (CMatrix.mult(RDM,RDM)).trace() ));
        }
        for ( let i = 0; i < n; ++i ) {
            let S = stats[i];
            let phaseInDegrees = S.phase / Math.PI * 180;
            let thetaInDegrees = S.theta / Math.PI * 180;
            console.log(
                `q${i}: (`
                    +"x="+StringUtil.numToString(S.x)+",y="+StringUtil.numToString(S.y)+",z="+StringUtil.numToString(S.z)
                +") ("
                    +"r="+StringUtil.numToString(S.radius)+","
                    +"phase="+StringUtil.numToString(S.phase)+"rad="+StringUtil.numToString(phaseInDegrees)+"deg,"
                    +"theta="+StringUtil.numToString(S.theta)+"rad="+StringUtil.numToString(thetaInDegrees)+"deg"
                +"), probability(|1>)=" + StringUtil.numToString(S.probabilityOfOne)
                +", purity=" + S.purity.toString()
                +", (" + S.psi_amplitude_0.toString() + ")|0>+(" + S.psi_amplitude_1.toString() + ")|1>"
            );
        }
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains correlation values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [-1,1] describing the correlation between qubits i,j
    // (where i>j).
    // The values -1, 0, +1 correspond to perfectly inverse correlation (i.e., when measured, qubits i,j always have opposite values),
    // uncorrelated, and perfectly positive correlation (i.e., when measured, the two qubits are always equal), respectively.
    // The diagonal and lower triangular half of the returned matrix contain zeros.
    // 
    // 
    // 
    // How to compute the correlation between two qubits:
    // 
    // Consider two qubits X and Y, each of which is measured to have
    // a value of either L (for Low) or H (for High).
    // (Later, we will consider (L,H)=(-1,+1) or (L,H)=(0,1).)
    // Define the four probabilities
    //     a = P((X,Y)=(L,L)) = P(X=L and Y=L)
    //     b = P((X,Y)=(L,H))
    //     c = P((X,Y)=(H,L))
    //     d = P((X,Y)=(H,H))
    // 
    // where a+b+c+d=1.
    // https://en.wikipedia.org/wiki/Correlation
    // explains that
    // 
    //     correlation(X,Y)
    //       = covariance(X,Y) / (sigma_X sigma_Y)
    //       = ( E(XY) - E(X)E(Y) ) / (sigma_X sigma_Y)
    // 
    // where sigma_X = sqrt(E(X^2) - E(X)^2)
    // and similarly for sigma_Y.
    // Thus
    //     covariance(X,Y)
    //       = E(XY) - E(X)E(Y)
    //       = aLL + bLH + cHL + dHH - ((a+b)L+(c+d)H) ((a+c)L+(b+d)H)
    //       = aLL+bLH+cHL+dHH - (aL+bL+cH+dH)(aL+cL+bH+dH)
    //       = aLL+bLH+cHL+dHH - (aaLL+abLL+acLL+bcLL + abLH+acLH+2adLH+bbLH+bdLH+ccLH+cdLH + bcHH+bdHH+cdHH+ddHH)
    // 
    // If we set (L,H)=(-1,+1), then sigma_X = sigma_Y = 1,
    // and
    //     covariance(X,Y)
    //       = a-b-c+d - (aa+ab+ac+bc - ab-ac-2ad-bb-bd-cc-cd + bc+bd+cd+dd)
    //       = a-b-c+d - (aa+2bc -2ad-bb-cc +dd)
    //       = a+d-b-c - (aa+dd+2bc-2ad-bb-cc)
    //     correlation(X,Y)
    //       = a+d-b-c - (aa+dd+2bc-2ad-bb-cc)
    // Recall that a=1-b-c-d. Substituting, we find
    //     correlation(X,Y)
    //       = (1-b-c-d)+d-b-c - ((1-b-c-d)^2+dd+2bc-2(1-b-c-d)d-bb-cc)
    //       = 1-2b-2c - ((1-b-c-d)^2+dd+2bc -2(d-bd-cd-dd) -bb-cc)
    //       = 1-2b-2c+2d +bb-2bc-2bd+cc-2cd-3dd - ((1-b-c-d)^2) 
    //       = 1-2b-2c+2d +bb-2bc-2bd+cc-2cd-3dd - (1-2b-2c-2d+bb+2bc+2bd+cc+2cd+dd)
    //       = 4d -4bc-4bd-4cd-4dd
    //       = 4(d-bd-cd-dd -bc)
    //       = 4((1-b-c-d)d -bc)
    //       = 4(ad-bc)    [1]
    // 
    // As a sanity check, set (L,H)=(0,1),
    // then sigma_X = sigma_Y = sqrt(0.5-0.5^2)=0.5,
    // and
    //     covariance(X,Y) = d - (bc+bd+cd+dd)
    //     correlation(X,Y)
    //       = (d - (bc+bd+cd+dd))/(0.5 0.5)
    //       = 4 (d - (bc+bd+cd+dd))
    //       = 4 (d - dd - bc - bd - cd)
    //       = 4( d - bc - (b+c+d)d )
    //       = 4( d - bc - (1-a)d )
    //       = 4( ad - bc )   [2]
    // We see that equation [2] is equivalent to [1].
    // 
    // As another sanity check, consider
    // the symmetrical situation
    // a=d and b=c, and define p=a=d.
    // Then b=c=0.5-p, and [2] yields
    //     correlation(X,Y)
    //       = 4( p^2 - (0.5-p)^2 )
    //       = 4( p^2 - 0.25+p-p^2 )
    //       = 4( -0.25+p )
    //       = 4p - 1
    // which yields -1,0,1, for p=0,0.25,0.5, respectively,
    // as expected.
    // 
    // As another sanity check, consider
    // the case b=c=0 (hence a+d=1).
    // Then [2] yields
    //     correlation(X,Y)
    //       = 4ad
    // which reaches a maximum of 1 when a=d=0.5.
    // Alternatively, consider the case a=d=0
    // (hence b+c=1), then [2] yields
    //     correlation(X,Y) = -4bc
    // which has a minimum of -1 when b=c=0.5
    // 
    // As another sanity check, consider the case
    // where X and Y are independent, with
    // probabilities
    //     p = P(X=H)
    //     q = P(Y=H)
    // Then P(X=L)=(1-p), P(Y=L)=(1-q),
    // a=(1-p)(1-q), b=(1-p)q, c=p(1-q), d=pq,
    // and we find
    //     correlation(X,Y)
    //       = 4( (1-p)(1-q)pq - (1-p)qp(1-q) )
    //       = 0
    // as expected.
    // 
    static computePairwiseQubitCorrelations( // TODO this needs more testing
        n, // number of qubits in the circuit
        stateVector // a matrix of size (2**n)x1, i.e. a column vector
    ) {
        Util.assert( stateVector._rows===(2**n) && stateVector._cols===1, "Sim.computePairwiseQubitCorrelations(): state vector has invalid size" );

        // compute the probability of each base state
        let baseStateProbabilities = new CMatrix( stateVector._rows, 1 );
        for ( let i=0; i < stateVector._rows; ++i ) baseStateProbabilities.set( i, 0, stateVector.get(i,0).mag()**2 );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                // p[bit_i][bit_j] is the probability of measuring (bit_i) at the ith bit and (bit_j) at the jth bit,
                // where bit_i, bit_j are each either 0 or 1
                let p = [ [ 0, 0 ], [ 0, 0 ] ];

                for ( let k=0; k < baseStateProbabilities._rows; ++k ) {
                    let bit_i = (k>>i) & 1;
                    let bit_j = (k>>j) & 1;
                    p[ bit_i ][ bit_j ] += baseStateProbabilities.get(k,0)._r;
                }
                let correlation = 4*( p[0][0]*p[1][1] - p[0][1]*p[1][0] );
                result.set( i, j, correlation );
                //console.log(`${i},${j}: `+StringUtil.numToString(p[0][0])+"+"+StringUtil.numToString(p[0][1])+"+"+StringUtil.numToString(p[1][0])+"+"+StringUtil.numToString(p[1][1])+"="+StringUtil.numToString(p[0][0]+p[0][1]+p[1][0]+p[1][1])+", diff="+StringUtil.numToString(correlation));
            }
        }
        //console.log("Pairwise correlations appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Attempts to perform an eigendecomposition of the given complex square matrix,
    // assuming that the resulting eigenvalues should all be real nonnegative, and returns these in an array.
    // If the eigendecomposition fails, this returns null.
    static eigendecomposition( matrix ) {
        Util.assert( matrix._rows===matrix._cols && matrix._rows > 1, "Sim.eigendecomposition(): matrix has invalid size" );
        let N = matrix._rows;

        // To use the mathjs library to find eigenvalues, we must convert the matrix to a format that mathjs understands
        let m2 = math.zeros(N,N);
        for ( let row = 0; row < N; ++row ) {
            for ( let col = 0; col < N; ++col ) {
                let entry = matrix.get(row,col);
                m2.set( [row,col], math.complex(entry._r,entry._i) );
            }
        }
        //console.log(`matrix ${i},${j} is \n` + m.toString() );
        //console.log("In mathjs format, the matrix is " + m2.toString());
        let E;
        try {
            // I tried increasing precision to as much as 0.01, but this still sometimes fails.
            E = math.eigs(m2,{eigenvectors: false, precision: 0.0001}).values._data;
                // .sort((a,b)=>b-a);
            //console.log(`Eigenvalues are ` + E.toString());
        } catch (error) {
            console.log("Sim.eigendecomposition() failed: ", error);
            console.log(`    Matrix was \n` + matrix.toString() );
            console.log("    In mathjs format, the matrix was " + m2.toString());
            console.log("    Error.values:" + error.values);
            return null;
        }
        let lambda = [];
        for ( let i = 0; i < E.length; i++) {
            lambda[i] = math.re(E[i]); // only keep the real part
            Util.assert( lambda[i] > -0.01, "Sim.eigendecomposition(): unexpected negative eigenvalue" );
            if ( lambda[i] < 0 ) lambda[i] = 0; // convert slightly negative real numbers to zero
        }
        return lambda;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains concurrence values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0,1] describing the concurrence between qubits i,j
    // (where i>j).
    //
    // The computation here is based on
    //    equations 1 and 2 in
    //    https://scholar.google.com/scholar?q=coffmann+kundu+wootters+Distributed+entanglement
    // which also matches the implementation in
    //    https://docs.quantum.ibm.com/api/qiskit/0.24/qiskit.quantum_info.concurrence
    //    https://github.com/Qiskit/qiskit/blob/stable/0.16/qiskit/quantum_info/states/measures.py
    //       (lines 208-213 at the end of the concurrence() routine)
    // More discussion is at
    //    https://physics.stackexchange.com/questions/46443/what-is-the-motivation-for-the-definition-of-concurrence-in-quantum-information
    static computePairwiseQubitConcurrences(
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computePairwiseQubitConcurrences(): density matrix has invalid size" );

        let result = new CMatrix(n,n);
        let Y_tensor_Y = CMatrix.tensor(Sim.Y,Sim.Y);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = Sim.computeReducedDensityMatrixForTwoQubits(i,j,n,densityMatrix);
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );
                let spin_flipped_rdm = CMatrix.naryMult([ Y_tensor_Y, rdm.conjugate(), Y_tensor_Y ]);
                let m = CMatrix.mult( rdm, spin_flipped_rdm );

                let lambda = Sim.eigendecomposition( m );
                if ( lambda === null ) {
                    // the eigendecomposition failed
                    const ERROR_VALUE = -0.1;
                    result.set( i, j, ERROR_VALUE );
                    continue;
                }

                // take square roots
                for ( let i = 0; i < lambda.length; i++) {
                    lambda[i] = Math.sqrt( lambda[i] );
                }

                let diffOfLambdas = lambda[3] - lambda[2] - lambda[1] - lambda[0];
                //console.log("    diff of lambdas:" + diffOfLambdas );

                let concurrence = (diffOfLambdas<0) ? 0 : diffOfLambdas;
                result.set( i, j, concurrence );
            }
        }
        //console.log("Pairwise concurrences appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains purity values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0.25,1] describing the purity for qubits i,j
    // (where i>j).
    // (In general, when considering n qubits, the purity computed from their 2^n x 2^n reduced density matrix
    // is in the range [1/2^n,1])
    //
    static computePairwiseQubitPurity(
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computePairwiseQubitPurity(): density matrix has invalid size" );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = Sim.computeReducedDensityMatrixForTwoQubits(i,j,n,densityMatrix);
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );
                result.set( i, j, (CMatrix.mult(rdm,rdm)).trace() );
            }
        }
        //console.log("Pairwise purities appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // Returns a matrix of size (n)x(n), whose upper triangular half contains entropy values for pairs of qubits.
    // Each cell (row=i,column=j) of the matrix contains a real number in [0,2] describing the entropy for qubits i,j
    // (where i>j).
    // (In general, when considering n qubits, the von Neumann entropy computed from their 2^n x 2^n reduced density matrix
    // is in the range [0,n])
    //
    // See
    //     https://quantumcomputing.stackexchange.com/questions/28708/how-is-the-von-neumann-entropy-of-a-state-defined-from-its-eigendecomposition
    //
    static computePairwiseQubitVonNeumannEntropy(
        n, // number of qubits in the circuit
        densityMatrix // a matrix of size (2**n)x(2**n)
    ) {
        let twoN = 2**n;
        Util.assert( densityMatrix._rows===twoN && densityMatrix._cols===twoN, "Sim.computePairwiseQubitVonNeumannEntropy(): density matrix has invalid size" );

        let result = new CMatrix(n,n);
        for ( let i=0; i <= n-2; ++i ) {
            for ( let j=i+1; j <= n-1; ++j ) {

                let rdm = Sim.computeReducedDensityMatrixForTwoQubits(i,j,n,densityMatrix);
                //console.log(`reduced density matrix ${i},${j} is \n` + rdm.toString() );

                let lambda = Sim.eigendecomposition( rdm );
                if ( lambda === null ) {
                    // the eigendecomposition failed
                    const ERROR_VALUE = -0.1;
                    result.set( i, j, ERROR_VALUE );
                    continue;
                }

                let entropy = 0;
                for ( let i = 0; i < lambda.length; ++i ) {
                    if ( lambda[i] > 0 )
                        entropy -= lambda[i] * Math.log2( lambda[i] );
                }
                //console.log(`  entropy is ${entropy}`);
                result.set( i, j, entropy );
            }
        }
        //console.log("Pairwise Von Neumann entropies appear in upper triangular half:\n" + result.toString());
        return result;
    }

    // If the client wants to, they could change the value of usingTextbookConvention
    // and call this again, to initialize things using a different convention.
    static init() {
        // When discussing quantum circuits,
        // the term 'bra', written <*|, denotes a row vector,
        // and the term 'ket', written |*>, denotes a column vector.
        // So an expression written as <a|b> means the dot product of a and b,
        // and the expression |a><b| results in a matrix as tall as a and as wide as b.
        // More precisely, <psi| is the conjugate transpose of |psi>.
        // If |psi> is made of complex amplitudes,
        // <psi|psi> is the sum of associated probabilities,
        // and the matrix |psi><psi| contains the probabilities along its diagonal.


        // Here we define the six canonical points on the Bloch sphere: the stabilizer states.
        //
        // |0>
        Sim.braZero = CMatrix.createRowVector([1,0]);
        Sim.ketZero = CMatrix.createColVector([1,0]);
        // |1>
        Sim.braOne = CMatrix.createRowVector([0,1]);
        Sim.ketOne = CMatrix.createColVector([0,1]);
        // |+>
        Sim.ketPlus = CMatrix.createColVector([Math.SQRT1_2,Math.SQRT1_2]);
        Sim.braPlus = Sim.ketPlus.conjugateTranspose();
        // |->
        Sim.ketMinus = CMatrix.createColVector([Math.SQRT1_2,-Math.SQRT1_2]);
        Sim.braMinus = Sim.ketMinus.conjugateTranspose();
        // |+i>
        Sim.ketPlusI = CMatrix.createColVector([Math.SQRT1_2,new Complex(0,Math.SQRT1_2)]);
        Sim.braPlusI = Sim.ketPlusI.conjugateTranspose();
        // |-i>
        Sim.ketMinusI = CMatrix.createColVector([Math.SQRT1_2,new Complex(0,-Math.SQRT1_2)]);
        Sim.braMinusI = Sim.ketMinusI.conjugateTranspose();

        // Here we define some commonly used logic gates.
        //
        Sim.ZERO = new CMatrix(2,2);
        Sim.I = CMatrix.identity(2);  // identity gate for a single qubit
        Sim.H = CMatrix.mult( CMatrix.create([[1,1],[1,-1]]), Math.SQRT1_2 ); // hadamard gate

        Sim.X = CMatrix.create([[0,1],[1,0]]); // a Pauli X gate, also called a NOT gate
        Sim.Y = CMatrix.create([[new Complex(0,0),new Complex(0,-1)],[new Complex(0,1),new Complex(0,0)]]);
        Sim.Z = CMatrix.create([[1,0],[0,-1]]); // the same thing as Phase(180)

        // "SX" means "Square root of X"
        Sim.SX = CMatrix.mult(
            CMatrix.create([[new Complex(1,1),new Complex(1,-1)],[new Complex(1,-1),new Complex(1,1)]]),
            0.5
        );
        // This is the inverse
        Sim.invSX = CMatrix.mult(
            CMatrix.create([[new Complex(1,-1),new Complex(1,1)],[new Complex(1,1),new Complex(1,-1)]]),
            0.5
        );
        // "SY" means "Square root of Y"
        Sim.SY = CMatrix.mult(
            CMatrix.create([[new Complex(1,1),new Complex(-1,-1)],[new Complex(1,1),new Complex(1,1)]]),
            0.5
        );
        Sim.invSY = CMatrix.mult(
            CMatrix.create([[new Complex(1,-1),new Complex(1,-1)],[new Complex(-1,1),new Complex(1,-1)]]),
            0.5
        );
        // "SZ" means "Square root of Z"; the same thing as Phase(90)
        Sim.SZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(0,1)]]
        );
        Sim.invSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(0,-1)]]
        );


        // The "SS" prefix in "SSX", "SSY", "SSZ" means "Square root of Square root", i.e., 4th root.
        // SSZ is the same thing as Phase(45).
        //
        //let cos_pi_over_8 = Math.cos(Math.PI/8);
        //let sin_pi_over_8 = Math.sin(Math.PI/8);
        let c1 = new Complex( (2+Math.SQRT2)/4 /* cos_pi_over_8*cos_pi_over_8 */, Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */ );
        let c2 = new Complex( (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */, - Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */ );
        Sim.SSX = CMatrix.create([[c1,c2],[c2,c1]]);
        let c1_ = new Complex( (2+Math.SQRT2)/4, - Math.SQRT1_2/2 );
        let c2_ = new Complex( (2-Math.SQRT2)/4, Math.SQRT1_2/2 );
        Sim.invSSX = CMatrix.create([[c1_,c2_],[c2_,c1_]]);
        c2 = new Complex( - Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */, - (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */ );
        c2_ = new Complex( Math.SQRT1_2/2 , - (2-Math.SQRT2)/4 );
        let c3 = new Complex( Math.SQRT1_2/2 /* sin_pi_over_8*cos_pi_over_8 */, (2-Math.SQRT2)/4 /* sin_pi_over_8*sin_pi_over_8 */ );
        let c3_ = new Complex( -Math.SQRT1_2/2 , (2-Math.SQRT2)/4 );
        Sim.SSY = CMatrix.create([[c1,c2],[c3,c1]]);
        Sim.invSSY = CMatrix.create([[c1_,c2_],[c3_,c1_]]);
        Sim.SSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,Math.SQRT1_2)]]
        );
        Sim.invSSZ = CMatrix.create(
            [[new Complex(1,0),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,-Math.SQRT1_2)]]
        );


        Sim.RX_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,0),new Complex(0,-Math.SQRT1_2)],[new Complex(0,-Math.SQRT1_2),new Complex(Math.SQRT1_2,0)]]);
        Sim.RY_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,0),new Complex(-Math.SQRT1_2,0)],[new Complex(Math.SQRT1_2,0),new Complex(Math.SQRT1_2,0)]]);
        Sim.RZ_90deg = CMatrix.create([[new Complex(Math.SQRT1_2,-Math.SQRT1_2),new Complex(0,0)],[new Complex(0,0),new Complex(Math.SQRT1_2,Math.SQRT1_2)]]);

        // qubit q0 is the control bit, qubit q1 is the target bit.
        // CX is also often called CNOT
        Sim.CX = CMatrix.create([[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]).reverseEndianness( ! usingTextbookConvention );
        Sim.SWAP_2 = Sim.SWAP(0,1,2); // a swap gate for a two-qubit circuit

        // Here we define some magic states.
        //
        // This is cos(pi/8)|0> + sin(pi/8)|1>  [ 0.924, 0.383 ]^T
        // and is given in Bravyi + Kitaev (2004), "Universal quantum computation with ideal Clifford gates and noisy ancillas", page 5, equation 3
        // In the bloch sphere, it's located at (phase=0, theta=45 degrees)
        // Other ways to compute the same state:
        //     CMatrix.naryMult( [ Sim.GlobalPhase(22.5), Sim.invSSY, Sim.H, Sim.ketZero ] );
        //     CMatrix.naryMult( [ Sim.GlobalPhase(-22.5), Sim.SSY, Sim.ketZero ] );
        Sim.ket_H_magic_state = CMatrix.createColVector([Math.cos(Math.PI/8),Math.sin(Math.PI/8)]);
        // This yields (1/2^0.5)(|0> + (e^(i pi/4))(|1>))  [ 0.707, 0.5+0.5i ]^T
        // and is given in Leone, Oliviero, Hamma (2022) "Stabilizer Rnyi Entropy", page 2, column 2.
        // In the bloch sphere, it's located at (phase=45 degrees, theta=90 degrees)
        Sim.ket_H_magic_state_2 = CMatrix.naryMult( [ Sim.SSZ, Sim.H, Sim.ketZero ] );
        // This is  [ 0.888, 0.325+0.325i ]^T
        // and is given in Bravyi + Kitaev (2004), "Universal quantum computation with ideal Clifford gates and noisy ancillas", page 5, equation 4
        // In the bloch sphere, it's located at (phase=45 degrees, theta54.7 degrees)
        let angle_beta = 0.5 * Math.acos(1/Math.sqrt(3));
        let sine_beta_over_root2 = Math.SQRT1_2 * Math.sin(angle_beta);
        Sim.ket_T_magic_state = CMatrix.createColVector([ Math.cos(angle_beta), new Complex(sine_beta_over_root2,sine_beta_over_root2) ]);

    }
}

Sim.init();



function performRegressionTest( verbose=true ) {
    console.log("Matrices are ordered according to " + (usingTextbookConvention?"textbook":"common software") + " convention.");

    let input, step1, step2, step3, output, expectedOutput, success;
    let allSuccessful = true;


    // Simulate a circuit on two qubits that entangles them,
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22],[%22%E2%80%A2%22,%22X%22]]}
    //
    // qubit q0 |0>----Hadamard-----o-----
    //                              |
    // qubit q1 |0>----------------(+)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.I /*q1*/, Sim.H /*q0*/, usingTextbookConvention );
    step2 = Sim.CX;
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0.707, 0, 0, 0.707 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'872ec24acc' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]]}
    //
    // qubit q0 |0>----o----(+)-
    //                 |
    // qubit q1 |0>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0,1,0,0 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'ec53d19216' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]],%22init%22:[1]}
    //
    // qubit q0 |1>----o----(+)-
    //                 |
    // qubit q1 |0>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketOne /*q0*/, usingTextbookConvention  );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ 0,0,1,0 ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'2bbcc438a1' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22]],%22init%22:[%22+%22,%22i%22]}
    //
    // qubit q0 |+>----o----(+)-
    //                 |
    // qubit q1 |i>---(+)-------
    //
    input = CMatrix.tensor( Sim.ketPlusI /*q1*/, Sim.ketPlus /*q0*/, usingTextbookConvention );
    step1 = Sim.CX;
    step2 = CMatrix.tensor( Sim.I /*q1*/, Sim.X /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0,0.5),0.5,0.5,new Complex(0,0.5) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'7e132563e4' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[{%22id%22:%22Rxft%22,%22arg%22:%22pi/2%22},{%22id%22:%22Rxft%22,%22arg%22:%22pi/2%22}],[%22%E2%80%A2%22,{%22id%22:%22Rzft%22,%22arg%22:%22pi/2%22}]]}
    //
    // qubit q0 |0>----RX(pi/2)--------o--------
    //                                 |
    // qubit q1 |0>----RX(pi/2)----(RZ(pi/2))---
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.RX_90deg /*q1*/, Sim.RX_90deg /*q0*/, usingTextbookConvention );
    output = CMatrix.mult( step1, input );
    output = Sim.transformStateVectorWith2x2( Sim.RZ_90deg,1,2,output,[[0,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "... = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0.5,0),new Complex(-0.35355,-0.35355),new Complex(0,-0.5),new Complex(-0.35355,-0.35355) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'be0c19df98' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22],[1,%22X^%C2%BC%22]]}
    //
    // qubit q0 |0>----(x^0.25)-----------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.SSY /*q1*/, Sim.SSX /*q0*/, usingTextbookConvention );
    step2 = CMatrix.tensor( Sim.SSX /*q1*/, Sim.I /*q0*/, usingTextbookConvention );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([ new Complex(0.42678, 0.67678),new Complex(0.28033, -0.17678),new Complex(0.42678, 0.17678),new Complex(0.07322, -0.17678) ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'21e10d99d6' );
    allSuccessful &= success;


    // Simulate a circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22,%22H%22],[1,%22X^%C2%BC%22],[1,%22Swap%22,%22Swap%22]]}
    //
    // qubit q0 |0>----(x^0.25)----------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----X-----
    //                                          |
    // qubit q2 |0>-------H---------------------X-----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.H /*q2*/, Sim.SSY /*q1*/, Sim.SSX /*q0*/ ], usingTextbookConvention );
    step2 = CMatrix.naryTensor( [ Sim.I /*q2*/, Sim.SSX /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );
    step3 = Sim.SWAP(1,2,3);
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString({decimalPrecision:1}),
        " * ",
        "...", // step1.toString({decimalPrecision:1}),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c4fee293c' );
    allSuccessful &= success;




    // Simulate a circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BC%22,%22Y^%C2%BC%22,%22H%22],[1,%22X^%C2%BC%22],[1,%22X%22,%22%E2%80%A2%22]]}
    //
    // qubit q0 |0>----(x^0.25)-------------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----(+)-----
    //                                           |
    // qubit q2 |0>-------H----------------------o------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.H /*q2*/, Sim.SSY /*q1*/, Sim.SSX /*q0*/ ], usingTextbookConvention );
    step2 = CMatrix.naryTensor( [ Sim.I /*q2*/, Sim.SSX /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );
    step3 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 3 );
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString({decimalPrecision:1}),
        " * ",
        "...", // step1.toString({decimalPrecision:1}),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.12500),
        new Complex(0.05178,-0.12500),
        new Complex(0.30178,0.47855),
        new Complex(0.19822,-0.12500)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c4dab5619' );
    allSuccessful &= success;




    // Simulate the same circuit, but this time without using explicit large matrices.
    //
    // qubit q0 |0>----(x^0.25)-------------------------
    //
    // qubit q1 |0>----(y^0.25)-----(x^0.25)----(+)-----
    //                                           |
    // qubit q2 |0>-------H----------------------o------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = Sim.transformStateVectorWith2x2(Sim.H,2,3,input,[]);
    step1 = Sim.transformStateVectorWith2x2(Sim.SSY,1,3,step1,[]);
    step1 = Sim.transformStateVectorWith2x2(Sim.SSX,0,3,step1,[]);
    step2 = Sim.transformStateVectorWith2x2(Sim.SSX,1,3,step1,[]);
    output = Sim.transformStateVectorWith2x2(Sim.X,1,3,step2,[[2,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        input.toString(),
        " -> ",
        step1.toString(),
        " -> ",
        step2.toString(),
        " -> ",
        output.toString({binaryPrefixes:true})
    ));
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'23abd31026' );
    allSuccessful &= success;





    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X^%C2%BD%22],[%22%E2%80%A2%22,%22X%22]],%22init%22:[0,%22-%22]}
    //
    // qubit q0 |0>---(x^0.5)----o-----
    //                           |
    // qubit q1 |->---(x^0.5)---(+)----
    //
    input = CMatrix.tensor( Sim.ketMinus /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.SX /*q1*/, Sim.SX /*q0*/, usingTextbookConvention );
    step2 = Sim.CX;
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(-0.35355, 0.35355),
        new Complex(-0.35355,-0.35355),
        new Complex( 0.35355,-0.35355),
        new Complex( 0.35355, 0.35355)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'1c58b99eac' );
    allSuccessful &= success;


    // Simulate another circuit on two qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X%22],[%22H%22,%22X^%C2%BD%22],[%22%E2%80%A2%22,%22X%22]]}
    //
    // qubit q0 |0>---(x^0.5)--hadamard----o-----
    //                                     |
    // qubit q1 |0>-----(+)-----(x^0.5)---(+)----
    //
    input = CMatrix.tensor( Sim.ketZero /*q1*/, Sim.ketZero /*q0*/, usingTextbookConvention );
    step1 = CMatrix.tensor( Sim.X /*q1*/, Sim.SX /*q0*/, usingTextbookConvention );
    step2 = CMatrix.tensor( Sim.SX /*q1*/, Sim.H /*q0*/, usingTextbookConvention );
    step3 = Sim.CX;
    output = CMatrix.naryMult([ step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step3.toString(),
        " * ",
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex( 0.35355,-0.35355),
        new Complex(-0.35355, 0.35355),
        new Complex( 0.35355, 0.35355),
        new Complex( 0.35355, 0.35355)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'723049b630' );
    allSuccessful &= success;


    // Simulate another circuit on three qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22X^%C2%BD%22,%22X^%C2%BD%22,%22X^%C2%BD%22],[1,%22X%22,%22%E2%80%A2%22]]}
    //
    // qubit q0 |0>---(x^0.5)--------
    //
    // qubit q1 |0>---(x^0.5)--(+)---
    //                          |
    // qubit q2 |0>---(x^0.5)---o----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = CMatrix.naryTensor( [ Sim.SX /*q2*/, Sim.SX /*q1*/, Sim.SX /*q0*/ ], usingTextbookConvention  );
    step2 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 3 );
    output = CMatrix.naryMult([ step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        step2.toString(),
        " * ",
        step1.toString(),
        " * ",
        input.toString(),
        " = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex(-0.25, 0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25,-0.25),
        new Complex( 0.25,-0.25),
        new Complex(-0.25,-0.25),
        new Complex( 0.25, 0.25),
        new Complex( 0.25,-0.25)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'c7cdcdc026' );
    allSuccessful &= success;


    // Simulate the same circuit, but this time without using explicit large matrices.
    //
    // qubit q0 |0>---(x^0.5)--------
    //
    // qubit q1 |0>---(x^0.5)--(+)---
    //                          |
    // qubit q2 |0>---(x^0.5)---o----
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention  );
    step1 = Sim.transformStateVectorWith2x2(Sim.SX,0,3,input,[]);
    step1 = Sim.transformStateVectorWith2x2(Sim.SX,1,3,step1,[]);
    step1 = Sim.transformStateVectorWith2x2(Sim.SX,2,3,step1,[]);
    output = Sim.transformStateVectorWith2x2(Sim.X,1,3,step1,[[2,true]]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        input.toString(),
        " -> ",
        step1.toString(),
        " -> ",
        output.toString({binaryPrefixes:true})
    ));
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'45cacd1026' );
    allSuccessful &= success;



    // Simulate a circuit on four qubits
    // equivalent to
    //     https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22,%22X^%C2%BD%22,1,%22X^%C2%BD%22],[%22%E2%80%A2%22,1,%22X%22],[1,%22X%22,%22%E2%80%A2%22],[1,%22%E2%80%A2%22,1,%22X%22],[1,%22H%22]]}
    //
    // qubit q0 |0>---hadamard---o--------------------------
    //                           |
    // qubit q1 |0>---(x^0.5)----|---(+)----o----hadamard---
    //                           |    |     |
    // qubit q2 |0>-------------(+)---o-----|---------------
    //                                      |
    // qubit q3 |0>---(x^0.5)--------------(+)--------------
    //
    input = CMatrix.naryTensor( [ Sim.ketZero /*q3*/, Sim.ketZero /*q2*/, Sim.ketZero /*q1*/, Sim.ketZero /*q0*/ ], usingTextbookConvention );
    step1 = CMatrix.naryTensor( [ Sim.SX /*q3*/, Sim.I /*q2*/, Sim.SX /*q1*/, Sim.H /*q0*/ ], usingTextbookConvention );
    step2 = Sim.expand4x4ForNWires( Sim.CX, 0, 2, 4 );
    step3 = Sim.expand4x4ForNWires( Sim.CX, 2, 1, 4 );
    step4 = Sim.expand4x4ForNWires( Sim.CX, 1, 3, 4 );
    step5 = CMatrix.naryTensor( [ Sim.I /*q3*/, Sim.I /*q2*/, Sim.H /*q1*/, Sim.I /*q0*/ ], usingTextbookConvention );

    output = CMatrix.naryMult([ step5, step4, step3, step2, step1, input ]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "... = ",
        output.toString({binaryPrefixes:true})
    ));
    expectedOutput = CMatrix.createColVector([
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0.5),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0.5, 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0.5, 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  , 0  ),
        new Complex( 0  ,-0.5)
    ]);
    success = CMatrix.approximatelyEqual(output,expectedOutput.reverseEndianness( usingTextbookConvention ));
    Util.assert( success, "Regression test failed "+'95b90f1b5d' );
    allSuccessful &= success;

    // Try simulating the same circuit, but this time without using explicit large matrices.
    output_method2 = Sim.transformStateVectorWith2x2(Sim.H,0,4,input,[]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.SX,1,4,output_method2,[]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.SX,3,4,output_method2,[]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.X,2,4,output_method2,[[0,true]]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.X,1,4,output_method2,[[2,true]]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.X,3,4,output_method2,[[1,true]]);
    output_method2 = Sim.transformStateVectorWith2x2(Sim.H,1,4,output_method2,[]);
    if ( verbose ) console.log(StringUtil.concatMultiline(
        "Difference found using a better method: ",
        CMatrix.diff(output,output_method2).transpose().toString()
    ));
    success = CMatrix.approximatelyEqual(output,output_method2);
    Util.assert( success, "Regression test failed "+'95b90f1b5d_B' );
    allSuccessful &= success;




    console.log( allSuccessful ? "All regression tests passed." : "At least one regression test failed." );
}

performRegressionTest(false);



// TODO add a swap matrix to this - but how ?
// Test the equivalence of two ways of transforming state vectors.
// One way uses an explicit matrix of size (2**n)x(2**n),
// the other uses a much less expensive way.
// If the output state vector is zero, the two methods found the same result.
n = 3;
let sv = new CMatrix(2**n,1); // state vector
for ( let i = 0; i < 2*(2**n); ++i ) sv._m[i] = Math.random();
console.log('random input state vector is ' + sv.transpose().toString())
for ( let ii = 0; ii < n; ++ii ){ // control bit
    for ( jj = 0; jj < n; ++jj ) { // 2x2 gate bit
        if ( ii===jj )
            continue;
        m_method1 = Sim.expand4x4ForNWires( Sim.CX, ii, jj, n );
        r_method1 = CMatrix.mult( m_method1, sv );
        m_method2 = Sim.X;
        r_method2 = Sim.transformStateVectorWith2x2(m_method2,jj,n,sv,[[ii,true]]);
        //console.log(r_method1.toString());
        //console.log(r_method2.toString());
        console.log(`    control bit on wire ${ii}, 2x2 gate on wire ${jj}, difference is ` + CMatrix.diff(r_method1,r_method2).transpose().toString());
    }
}


// Simulate a circuit containing many ccnot, cnot, and other gates.
let time0 = (new Date()).getTime();
n = 4;
let numGates = 0;
let sv0 = new CMatrix(2**n,1); // state vector
sv0.set(0,0,1);
sv = sv0.copy();
for ( let ii = 0; ii < n; ++ii ) {
    // apply a gate to the (ii)th wire
    if ( ii%3===0 ) {
        console.log(`h at ${ii}`);
        sv = Sim.transformStateVectorWith2x2(Sim.H,ii,n,sv,[]);
    }
    else if ( ii%3===1 ) {
        console.log(`rootx at ${ii}`);
        sv = Sim.transformStateVectorWith2x2(Sim.SX,ii,n,sv,[]);
    }
    else {
        console.log(`fourthrooty at ${ii}`);
        sv = Sim.transformStateVectorWith2x2(Sim.SSY,ii,n,sv,[]);
    }
    numGates ++;
}
console.log("output is "+sv.transpose().toString());
for ( let ii = 0; ii < Math.floor(n/2); ++ii ) {
    // add a ccnot gate on random wires
    let jj1 = Math.floor( Math.random() * n );
    let jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    let jj3 = Math.floor( Math.random() * (n-2) );
    if ( jj3 === jj1 || jj3 === jj2 ) jj3++;
    if ( jj3 === jj1 || jj3 === jj2 ) jj3++;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && 0<=jj3 && jj3<n && jj1!==jj2 && jj2!==jj3 && jj1!==jj3, "unexpected condition 1" );
    console.log(`ccnot at ${jj1}, ${jj2}, ${jj3}`);
    sv = Sim.transformStateVectorWith2x2(Sim.X,jj3,n,sv,[[jj1,true],[jj2,true]]);
    numGates ++;
    console.log("output is "+sv.transpose().toString());

    // add a swap gate on random wires
    jj1 = Math.floor( Math.random() * n );
    jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && jj1!==jj2, "unexpected condition 2" );
    console.log(`swap at ${jj1}, ${jj2}`);
    sv = Sim.transformStateVectorWithSwap(jj1,jj2,n,sv);
    numGates ++;
    console.log("output is "+sv.transpose().toString());

    // add a cnot gate on random wires
    jj1 = Math.floor( Math.random() * n );
    jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && jj1!==jj2, "unexpected condition 3" );
    console.log(`cnot at ${jj1}, ${jj2}`);
    sv = Sim.transformStateVectorWith2x2(Sim.X,jj2,n,sv,[[jj1,true]]);
    numGates ++;
    console.log("output is "+sv.transpose().toString());

    // add a cfourthrootx gate on random wires
    jj1 = Math.floor( Math.random() * n );
    jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && jj1!==jj2, "unexpected condition 4" );
    console.log(`cfourthrootx at ${jj1}, ${jj2}`);
    sv = Sim.transformStateVectorWith2x2(Sim.SSX,jj2,n,sv,[[jj1,true]]);
    numGates ++;
    console.log("output is "+sv.transpose().toString());

    // add a cfourthrooty gate on random wires
    jj1 = Math.floor( Math.random() * n );
    jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && jj1!==jj2, "unexpected condition 5" );
    console.log(`cfourthrooty at ${jj1}, ${jj2}`);
    sv = Sim.transformStateVectorWith2x2(Sim.SSY,jj2,n,sv,[[jj1,true]]);
    numGates ++;
    console.log("output is "+sv.transpose().toString());

    // add a ch gate on random wires
    jj1 = Math.floor( Math.random() * n );
    jj2 = Math.floor( Math.random() * (n-1) );
    if ( jj2 === jj1 ) jj2=n-1;
    Util.assert(0<=jj1 && jj1<n && 0<=jj2 && jj2<n && jj1!==jj2, "unexpected condition 6" );
    console.log(`ch at ${jj1}, ${jj2}`);
    sv = Sim.transformStateVectorWith2x2(Sim.H,jj2,n,sv,[[jj1,true]]);
    numGates ++;
    console.log("output is "+sv.transpose().toString());
}
console.log("output is "+sv.transpose().toString());
let time1 = (new Date()).getTime();
let timeTaken = time1 - time0; // in milliseconds
console.log(`${numGates} gates on ${n} qubits in ${timeTaken} milliseconds`);

</script>
</body>
</html>

